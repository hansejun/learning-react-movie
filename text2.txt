[ sort 메소드를 활용해 최신순 정렬하기 ]
- itmes.sort((a,b) => b.createdAt - a.createdAt)

[ filter 메소드를 활용해 아이템 삭제하기 ]
- items.filter((item) => item.id !== id);
- id와 같지 않은 것들로 만들어진 배열 생성

----------------------------------------------------
[ 배열 렌더링 ]

1) map 함수로 렌더링하기
  <ul>
    {items.map((item) => (
      <li key={item.id}>
        <Pokemon item={item} />
      </li>
    ))}
  </ul>

2) sort로 정렬하기

3) filter로 삭제하기 

4) 반드시 key prop을 주기
 
 ----------------------------------------------------
 [ fetch 사용해서 데이터 불러오기 ]

 export const getReviews = async () => {
  const response = await fetch("https://learn.codeit.kr/api/film-reviews");
  const body = await response.json();
  return body;
};
 
----------------------------------------------------
[ useEffect ]

1) 처음 한번만 실행하기

- useEffect(() => {
    // 실행할 코드
  }, []);

--> 컴포넌트가 처음 렌더링 되고 나면 리액트가 콜백 함수를 기억해뒀다가 실행합니다.
    그 이후로는 콜백 함수를 실행하지 않습니다.

2) 값이 바뀔 때마다 실행하기

- useEffect(() => {
    // 실행할 코드
  }, [dep1, dep2, dep3, ...]);

--> 컴포넌트가 처음 렌더링 되고 나면 리액트가 콜백 함수를 기억해뒀다가 실행합니다.
    그 이후로 렌더링 할 때는 디펜던시 리스트에 있는 값들을 확인해서
    하나라도 바뀌면  콜백 함수를 기억해뒀다가 실행합니다.
 
----------------------------------------------------
[ 페이지네이션 ]

1) 오프셋 기반의 페이지네이션
- 개수를 기준으로 데이터를 나눈다.
- 개수를 기준으로 하기 때문에 데이터를 받아오는 과정에서 추가/삭제가 이루어지면 원하지 않는 결과가 나올 수 있다.
- 20번째부터 30번째까지 가져와줘!
- ?offset=20&limit=10

2) 커서 기반의 페이지네이션
- 데이터를 가리키는 값. 지금까지 받아온 데이터에 표시를 하여 나눈다.
- 커서값:ddadwd 이후의 데이터 10개를 가져와줘!


----------------------------------------------------
[ 조건부 렌더링 ]

1) AND 연산자
<div>
  <button onClick={handleClick}>토글</button>
  {show && <p>보인다 👀</p>}
</div>

==> show의 값이 true면 <p>를 렌더링 
    false면 show를 렌더링한다.

2) OR 연산자
<div>
  <button onClick={handleClick}>토글</button>
  <hide || <p>보인다 👀</p>}
</div>

=> hide 값이 true 이면 렌더링 하지 않고, false 이면 렌더링 합니다.




